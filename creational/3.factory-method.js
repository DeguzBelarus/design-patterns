// Фабричный метод (англ. Factory Method), или виртуальный конструктор (англ. Virtual Constructor) — порождающий шаблон проектирования,
// предоставляющий подклассам (дочерним классам, субклассам) интерфейс для создания экземпляров некоторого класса. В момент создания наследники
// могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса.
// Это позволяет использовать в коде программы не конкретные классы, а манипулировать абстрактными объектами на более высоком уровне.

// Цель
// Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, на основании какого класса создавать объект. Фабричный
// метод позволяет классу делегировать создание подклассов. Используется, когда:
// - классу заранее неизвестно, объекты каких подклассов ему нужно создавать;
// - класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами;
// - класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс
// принимает эти обязанности на себя.

// Структура
// Product — продукт: определяет интерфейс объектов, создаваемых абстрактным методом;
// ConcreteProduct — конкретный продукт: реализует интерфейс Product;
// Creator — создатель: 
// - объявляет фабричный метод, который возвращает объект типа Product. 
// Может также содержать реализацию этого метода «по умолчанию»;
// - может вызывать фабричный метод для создания объекта типа Product;
// ConcreteCreator — конкретный создатель: переопределяет фабричный метод таким образом, чтобы он создавал
// и возвращал объект класса ConcreteProduct.

// Достоинства
// - позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам (ConcreteProduct), а
// оперируя лишь общим интерфейсом (Product);
// - позволяет установить связь между параллельными иерархиями классов.

// Недостатки
// - необходимость создавать наследника Creator для каждого нового типа продукта (ConcreteProduct).

// Реализация
class Product {
  getName() {
    return null;
  }
}

class ConcreteProductA extends Product {
  getName() {
    return 'Product A'
  }
}

class ConcreteProductB extends Product {
  getName() {
    return 'Product B'
  }
}

class Creator {
  factoryMethod() {}
}

class ConcreteCreatorA extends Creator {
  factoryMethod() {
    return new ConcreteProductA()
  }
}

class ConcreteCreatorB extends Creator {
  factoryMethod() {
    return new ConcreteProductB()
  }
}

// Массив создателей (Creator)
const creators = [new ConcreteCreatorA(), new ConcreteCreatorB()]
const products = []

// Перебрать массив создателей (Creator) и добавить конкретные товары (ConcreteProduct) в массив products
for (const concreteCreator of creators) {
  products.push(concreteCreator.factoryMethod().getName())
}

console.log(products) // Вывод: [ 'Product A', 'Product B' ]