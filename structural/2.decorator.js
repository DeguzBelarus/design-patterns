// Декоратор (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к
// объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.

// Задача
// Объект, который предполагается использовать, выполняет основные функции. Однако может потребоваться добавить к нему некоторую дополнительную
// функциональность, которая будет выполняться до, после или даже вместо основной функциональности объекта.

// Способ решения
// Декоратор предусматривает расширение функциональности объекта без определения подклассов.

// Участники
// Класс ConcreteComponent — класс, в который с помощью шаблона Декоратор добавляется новая функциональность. В некоторых случаях базовая
// функциональность предоставляется классами, производными от класса ConcreteComponent. В подобных случаях класс ConcreteComponent является уже не
// конкретным, а абстрактным. Абстрактный класс Component определяет интерфейс для использования всех этих классов.

// Следствия
// 1 Добавляемая функциональность реализуется в небольших объектах. Преимущество состоит в возможности динамически добавлять эту функциональность до
// или после основной функциональности объекта ConcreteComponent.
// 2 Позволяет избегать перегрузки функциональными классами на верхних уровнях иерархии
// 3 Декоратор и его компоненты не являются идентичными

// Реализация
// Создаётся абстрактный класс, представляющий как исходный класс, так и новые, добавляемые в класс функции. В классах-декораторах новые функции
// вызываются в требуемой последовательности — до или после вызова последующего объекта.

// При желании остаётся возможность использовать исходный класс(без расширения функциональности), если на его объект сохранилась ссылка.

// Замечания и комментарии
// - Хотя объект-декоратор может добавлять свою функциональность до или после функциональности основного объекта, цепочка создаваемых объектов
// всегда должна заканчиваться объектом класса ConcreteComponent.
// - Базовые классы языка Java широко используют шаблон Декоратор для организации обработки операций ввода - вывода.
// - И декоратор, и адаптер являются обёртками вокруг объекта — хранят в себе ссылку на оборачиваемый объект и часто передают в него вызовы методов.
// Отличие декоратора от адаптера в том, что адаптер имеет внешний интерфейс, отличный от интерфейса оборачиваемого объекта, и используется именно
// для стыковки разных интерфейсов.Декоратор же имеет точно такой же интерфейс, и используется для добавления функциональности.
// - Для расширения функциональности класса возможно использовать как декораторы, так и стратегии.Декораторы оборачивают объект снаружи, стратегии же
// вставляются в него внутрь по неким интерфейсам.
// -- Недостаток стратегии: класс должен быть спроектирован с возможностью вставления стратегий, декоратор же не требует такой поддержки.
// -- Недостаток декоратора: он оборачивает ровно тот же интерфейс, что предназначен для внешнего мира, что вызывает смешение публичного интерфейса и
// интерфейса кастомизации, которое не всегда желательно.

// Применение шаблона
// Драйверы-фильтры в ядре Windows (архитектура WDM (Windows Driver Model)) представляют собой декораторы. Несмотря на то, что WDM реализована на
// не-объектном языке Си, в ней чётко прослеживаются паттерны проектирования — декоратор, цепочка обязанностей, и команда (объект IRP).
// Архитектура COM(Component Object Model) не поддерживает наследование реализаций, вместо него предлагается использовать декораторы(в данной
// архитектуре это называется «агрегация»).При этом архитектура решает (с помощью механизма pUnkOuter) проблему object identity, возникающую при
// использовании декораторов — identity агрегата есть identity его самого внешнего декоратора.

// Примеры
// Шаблон декоратор в языках с динамической типизацией может быть применён без интерфейсов и традиционного для ООП наследования.
// Этот пример скопирован с английской версии статьи. Расчёт стоимости кофе:

// ConcreteComponent (класс для последующего декорирования)
function Coffee() {
  this.cost = function () {
    return 1;
  };
}
// Decorator A
function Milk(coffee) {
  this.cost = function () {
    return coffee.cost() + 0.5;
  };
}
// Decorator B
function Whip(coffee) {
  this.cost = function () {
    return coffee.cost() + 0.7;
  };
}
// Decorator C
function Sprinkles(coffee) {
  this.cost = function () {
    return coffee.cost() + 0.2;
  };
}

// Использование:
var coffee = new Milk(new Whip(new Sprinkles(new Coffee())));
console.log(coffee.cost()); // 2.4 = 1 + 0.5 + 0.7 + 0.2

// Более наглядно:
var coffee = new Coffee();
coffee = new Sprinkles(coffee);
coffee = new Whip(coffee);
coffee = new Milk(coffee);
console.log(coffee.cost()); // 2.4 = 1 + 0.5 + 0.7 + 0.2
